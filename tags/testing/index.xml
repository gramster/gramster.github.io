<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Testing on Graham Wheeler's Random Forest</title><link>https://www.grahamwheeler.com/tags/testing/</link><description>Recent content in Testing on Graham Wheeler's Random Forest</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 26 Jun 2021 16:19:57 +0000</lastBuildDate><atom:link href="https://www.grahamwheeler.com/tags/testing/index.xml" rel="self" type="application/rss+xml"/><item><title>Unit Tests that Don't Suck</title><link>https://www.grahamwheeler.com/post/unit-tests-that-dont-suck/</link><pubDate>Sat, 26 Jun 2021 16:19:57 +0000</pubDate><guid>https://www.grahamwheeler.com/post/unit-tests-that-dont-suck/</guid><description>tl;dr This is a long post. I think its valuable reading, but I can also sum up my recommendations as:
Build good but narrow APIs that are the public contracts for your code. Focus your tests on these. Don&amp;rsquo;t bother testing at the level of methods, classes, etc, except insofar as these represent the public APIs, with the exception of complex algorithms that may need particular attention.
Introduction This post is based on a talk I gave to my team in an effort to establish a common approach to thinking about unit tests.</description></item></channel></rss>